function createComposite(context is Context, baseId is Id,
    tubeWidth is ValueWithUnits, tubeWallThickness is ValueWithUnits,
    frameDepth is ValueWithUnits, segmentHeight is ValueWithUnits, segmentLength is ValueWithUnits,
    endX is ValueWithUnits, offset is Vector, facingDirection is ValueWithUnits) returns map
{
    const innerWidth = tubeWidth - 2 * tubeWallThickness;
    const halfTube = tubeWidth / 2;
    const halfInner = innerWidth / 2;
    const zero = 0 * inch;
    const localOrigin = vector(zero, zero, zero); // Build at origin
    
    // Maintain indexed array of all created objects
    var createdObjects = {};
    createdObjects["flatBars"] = []; // Array of all flat bars with their metadata
    
    // Create first upper frame piece at origin
    // segmentHeight is used as the depth (Y dimension) of the joiner before rotation
    // After rotation, frameDepth becomes the height (Z)
    const piece1FlatBars = createUpperFramePiece(context, baseId + "piece1",
        tubeWidth, tubeWallThickness, innerWidth, halfTube, halfInner,
        frameDepth, segmentHeight,
        endX, localOrigin);
    
    // Store piece1 flat bars with metadata
    createdObjects["flatBars"] = append(createdObjects["flatBars"], {
        "pieceId" : "piece1",
        "zOffset" : 0 * inch,
        "backFlatBar" : piece1FlatBars["backFlatBar"],
        "frontFlatBar" : piece1FlatBars["frontFlatBar"]
    });
    
    // Create second upper frame piece, translated upward by segment height (height of one piece)
    const secondPieceOffset = localOrigin + vector(zero, zero, segmentHeight);
    const piece2FlatBars = createUpperFramePiece(context, baseId + "piece2",
        tubeWidth, tubeWallThickness, innerWidth, halfTube, halfInner,
        frameDepth, segmentHeight,
        endX, secondPieceOffset);
    
    // Store piece2 flat bars with metadata
    createdObjects["flatBars"] = append(createdObjects["flatBars"], {
        "pieceId" : "piece2",
        "zOffset" : segmentHeight,
        "backFlatBar" : piece2FlatBars["backFlatBar"],
        "frontFlatBar" : piece2FlatBars["frontFlatBar"]
    });
    
    // Create a horizontal rectangular tube on top of the frame stack
    // Dimensions: tubeWidth x 2 wide, tubeWidth tall
    // Position it at the top of the second frame piece
    // Top pieces should be at segmentHeight * 2 + tubeWidth
    const topOfSecondPieceZ = localOrigin[2] + segmentHeight * 2 + tubeWidth;
    const rectTubeWidth = tubeWidth * 2;
    const rectTubeHeight = tubeWidth;
    const rectTubeLength = frameDepth; // Match the frame depth
    const halfRectWidth = rectTubeWidth / 2;
    const halfRectHeight = rectTubeHeight / 2;
    const innerRectWidth = rectTubeWidth - 2 * tubeWallThickness;
    const innerRectHeight = rectTubeHeight - 2 * tubeWallThickness;
    const halfInnerRectWidth = innerRectWidth / 2;
    const halfInnerRectHeight = innerRectHeight / 2;
    
    // Create rectangular tube horizontally along Y axis (front to back)
    // Build at origin - no Y offset
    const rectTubeCenterY = zero - 0.5 * tubeWidth;
    const rectTubeZ = topOfSecondPieceZ + 0.5 * tubeWidth;
    const rectTubeStart = localOrigin + vector(endX, rectTubeCenterY, rectTubeZ);
    const rectTubeEnd = localOrigin + vector(endX, rectTubeCenterY + rectTubeLength, rectTubeZ);
    const rectTubeDirection = normalize(rectTubeEnd - rectTubeStart);
    
    // Create outer rectangle sketch (tubeWidth x tubeWidth*2 cross-section)
    const rectTubeOuterSketchId = baseId + "rectTubeOuterSketch";
    const rectTubeOuterSketch = newSketchOnPlane(context, rectTubeOuterSketchId, {
        "sketchPlane" : plane(rectTubeStart, rectTubeDirection)
    });
    skRectangle(rectTubeOuterSketch, "outerRect", {
        "firstCorner" : vector(-halfRectWidth, -halfRectHeight),
        "secondCorner" : vector(halfRectWidth, halfRectHeight)
    });
    skSolve(rectTubeOuterSketch);
    
    const rectTubeOuterRegions = qSketchRegion(rectTubeOuterSketchId);
    opExtrude(context, baseId + "rectTubeOuter", {
        "entities" : rectTubeOuterRegions,
        "direction" : rectTubeDirection,
        "endBound" : BoundingType.BLIND,
        "endDepth" : rectTubeLength,
        "operationType" : NewBodyOperationType.NEW
    });
    
    // Create inner rectangle sketch for hollow tube
    const rectTubeInnerSketchId = baseId + "rectTubeInnerSketch";
    const rectTubeInnerSketch = newSketchOnPlane(context, rectTubeInnerSketchId, {
        "sketchPlane" : plane(rectTubeStart, rectTubeDirection)
    });
    skRectangle(rectTubeInnerSketch, "innerRect", {
        "firstCorner" : vector(-halfInnerRectWidth, -halfInnerRectHeight),
        "secondCorner" : vector(halfInnerRectWidth, halfInnerRectHeight)
    });
    skSolve(rectTubeInnerSketch);
    
    const rectTubeInnerRegions = qSketchRegion(rectTubeInnerSketchId);
    opExtrude(context, baseId + "rectTubeInner", {
        "entities" : rectTubeInnerRegions,
        "direction" : rectTubeDirection,
        "endBound" : BoundingType.BLIND,
        "endDepth" : rectTubeLength,
        "operationType" : NewBodyOperationType.NEW
    });
    
    // Subtract inner from outer to create hollow rectangular tube
    opBoolean(context, baseId + "rectTubeSubtract", {
        "tools" : qBodyType(qCreatedBy(baseId + "rectTubeInner", EntityType.BODY), BodyType.SOLID),
        "operationType" : BooleanOperationType.SUBTRACTION,
        "targets" : qBodyType(qCreatedBy(baseId + "rectTubeOuter", EntityType.BODY), BodyType.SOLID)
    });
    
    // Apply offset to rectangular tube: +0.5 on Y, -0.5 on Z
    const rectTubeQuery = qBodyType(qCreatedBy(baseId + "rectTubeOuter", EntityType.BODY), BodyType.SOLID);
    const rectTubeOffsetTransform = transform(vector(zero, 0.5 * inch, -0.5 * inch));
    opTransform(context, baseId + "rectTubeOffset", {
        "bodies" : rectTubeQuery,
        "transform" : rectTubeOffsetTransform
    });
    
    // Create a square tube oriented horizontally along X axis (orthogonal to rectangular tube)
    // Length is segmentLength, top face aligned with top face of rectangular tube
    // One end butts up to the broad side upper corner of the rectangular tube
    const rectTubeTopZ = rectTubeZ + halfRectHeight; // Top face of rectangular tube
    const squareTubeTopZ = rectTubeTopZ; // Align top faces
    const squareTubeCenterZ = squareTubeTopZ - halfTube; // Center Z of square tube
    const squareTubeLength = segmentLength;
    
    // Broad side upper corner of rectangular tube:
    // - X edge: endX + halfRectWidth = endX + tubeWidth (outer edge)
    // - Y: rectTubeCenterY (start end)
    // - Z: rectTubeTopZ (top face)
    // Apply offsets: -0.5*tubeWidth on X, +0.5*tubeWidth on Y, +0.5*tubeWidth on Z
    const cornerX = endX + halfRectWidth - 0.5 * tubeWidth;
    const cornerY = rectTubeCenterY + 0.5 * tubeWidth;
    const cornerZ = squareTubeCenterZ + 0.5 * tubeWidth;
    
    // Square tube runs along X axis, starting at the corner
    const squareTubeStart = localOrigin + vector(cornerX, cornerY, cornerZ);
    const squareTubeEnd = localOrigin + vector(cornerX + squareTubeLength, cornerY, cornerZ);
    createTube(context, baseId + "squareTube",
        squareTubeStart,
        squareTubeEnd,
        halfTube, halfInner, tubeWidth, tubeWallThickness);
    
    // Duplicate the square tube and translate it along Y by frameDepth - tubeWidth
    const duplicateYOffset = frameDepth - tubeWidth;
    const duplicateTubeStart = localOrigin + vector(cornerX, cornerY + duplicateYOffset, cornerZ);
    const duplicateTubeEnd = localOrigin + vector(cornerX + squareTubeLength, cornerY + duplicateYOffset, cornerZ);
    createTube(context, baseId + "squareTubeDuplicate",
        duplicateTubeStart,
        duplicateTubeEnd,
        halfTube, halfInner, tubeWidth, tubeWallThickness);
    
    // Apply offset to the two square tubes: +0.5 on Y, -0.5 on Z
    const squareTubeQuery = qBodyType(qCreatedBy(baseId + "squareTube" + "outer", EntityType.BODY), BodyType.SOLID);
    const squareTubeDuplicateQuery = qBodyType(qCreatedBy(baseId + "squareTubeDuplicate" + "outer", EntityType.BODY), BodyType.SOLID);
    const squareTubeOffsetTransform = transform(vector(zero, 0.5 * inch, -0.5 * inch));
    opTransform(context, baseId + "squareTubeOffset", {
        "bodies" : qUnion([squareTubeQuery, squareTubeDuplicateQuery]),
        "transform" : squareTubeOffsetTransform
    });
    
    // Delete the bottom flat bar (frontFlatBar) from the second frame piece
    // This is the third flat bar (the lower one of the duplicated pair)
    // It will be replaced by the parallel tube
    const secondPieceFrontFlatBar = qBodyType(qCreatedBy(baseId + "piece2" + "joiner" + "frontFlatBar", EntityType.BODY), BodyType.SOLID);
    opDeleteBodies(context, baseId + "deleteSecondFrontFlatBar", {
        "entities" : secondPieceFrontFlatBar
    });
    
    // Extend the two tubes from the second frame piece downward by 0.125" to fill the gap
    const extendDistance = 0.125 * inch;
    const flatBarThicknessValue = 0.125 * inch;
    const tubeTranslation = flatBarThicknessValue;
    const tubeStartY = halfTube + tubeTranslation;
    
    // Second piece bottom is at segmentHeight; add tubeWidth to align extensions flush
    const secondPieceBottomZ = localOrigin[2] + segmentHeight + tubeWidth - tubeStartY + 0.25 * inch;
    
    // Top tube Y position after rotation: frameDepth - tubeWidth
    // Build at origin - no Y offset
    const topTubeY = frameDepth - tubeWidth;
    // Bottom tube Y position after rotation: 0
    const bottomTubeY = zero;
    
    // Create extensions at the calculated positions
    // Extend slightly upward to ensure overlap with the tubes for union
    const overlapDistance = 0.01 * inch; // Small overlap to ensure union works
    const topTubeExtensionStart = localOrigin + vector(endX, topTubeY, secondPieceBottomZ + overlapDistance);
    const topTubeExtensionEnd = topTubeExtensionStart + vector(zero, zero, -extendDistance - overlapDistance);
    createTube(context, baseId + "extendTopTubeDownward",
        topTubeExtensionStart,
        topTubeExtensionEnd,
        halfTube, halfInner, tubeWidth, tubeWallThickness);
    
    const bottomTubeExtensionStart = localOrigin + vector(endX, bottomTubeY, secondPieceBottomZ + overlapDistance);
    const bottomTubeExtensionEnd = bottomTubeExtensionStart + vector(zero, zero, -extendDistance - overlapDistance);
    createTube(context, baseId + "extendBottomTubeDownward",
        bottomTubeExtensionStart,
        bottomTubeExtensionEnd,
        halfTube, halfInner, tubeWidth, tubeWallThickness);
    
    // Union the extensions with the original tubes
    const secondPieceTopTubeQuery = qBodyType(qCreatedBy(baseId + "piece2" + "joiner" + "topY" + "outer", EntityType.BODY), BodyType.SOLID);
    const secondPieceBottomTubeQuery = qBodyType(qCreatedBy(baseId + "piece2" + "joiner" + "bottomY" + "outer", EntityType.BODY), BodyType.SOLID);
    const topTubeExtensionQuery = qBodyType(qCreatedBy(baseId + "extendTopTubeDownward" + "outer", EntityType.BODY), BodyType.SOLID);
    const bottomTubeExtensionQuery = qBodyType(qCreatedBy(baseId + "extendBottomTubeDownward" + "outer", EntityType.BODY), BodyType.SOLID);
    
    // Apply offset to extensions: +0.5 on Y, -0.5 on Z (before swapping)
    const extensionOffsetTransform = transform(vector(zero, 0.5 * inch, -0.5 * inch));
    opTransform(context, baseId + "extensionOffset", {
        "bodies" : qUnion([topTubeExtensionQuery, bottomTubeExtensionQuery]),
        "transform" : extensionOffsetTransform
    });
    
    // Swap extensions to match correct tubes
    const secondPieceTopTube = secondPieceTopTubeQuery;
    const secondPieceBottomTube = secondPieceBottomTubeQuery;
    const topTubeExtension = bottomTubeExtensionQuery; // Swap: use bottom extension for top tube
    const bottomTubeExtension = topTubeExtensionQuery; // Swap: use top extension for bottom tube
    
    // Union operations
    const topTubeCount = size(evaluateQuery(context, secondPieceTopTube));
    const bottomTubeCount = size(evaluateQuery(context, secondPieceBottomTube));
    const topExtensionCount = size(evaluateQuery(context, topTubeExtension));
    const bottomExtensionCount = size(evaluateQuery(context, bottomTubeExtension));
    
    if (topTubeCount > 0 && topExtensionCount > 0)
    {
        opBoolean(context, baseId + "unionTopTube", {
            "tools" : qUnion([secondPieceTopTube, topTubeExtension]),
            "operationType" : BooleanOperationType.UNION
        });
    }
    
    if (bottomTubeCount > 0 && bottomExtensionCount > 0)
    {
        opBoolean(context, baseId + "unionBottomTube", {
            "tools" : qUnion([secondPieceBottomTube, bottomTubeExtension]),
            "operationType" : BooleanOperationType.UNION
        });
    }
    
    // Create a square tube parallel to the flat bar, matching its length
    // After rotation, flat bars are horizontal along Y axis (front to back)
    // The flat bar length is frameDepth (horizontal Y dimension after rotation)
    // Shorten by tubeWidth x 2 and move along its length by tubeWidth
    const flatBarLength = frameDepth;
    const tubeX = 0.5 * tubeWidth;
    const tubeY = zero; // Build at origin - no Y offset
    // First parallel tube (purple) should be at segmentHeight
    const tubeZ = segmentHeight + tubeWidth;
    const shortenedLength = flatBarLength - (tubeWidth * 2);
    const tubeStart = localOrigin + vector(tubeX, tubeY + tubeWidth, tubeZ); // Move along Y by tubeWidth
    const tubeEnd = localOrigin + vector(tubeX, tubeY + tubeWidth + shortenedLength, tubeZ);
    createTube(context, baseId + "parallelTube",
        tubeStart,
        tubeEnd,
        halfTube, halfInner, tubeWidth, tubeWallThickness);
    
    // Apply offset to parallel tube: -0.5 on Z
    const parallelTubeQuery = qBodyType(qCreatedBy(baseId + "parallelTube" + "outer", EntityType.BODY), BodyType.SOLID);
    const parallelTubeOffsetTransform = transform(vector(zero, zero, -0.5 * inch));
    opTransform(context, baseId + "parallelTubeOffset", {
        "bodies" : parallelTubeQuery,
        "transform" : parallelTubeOffsetTransform
    });
    
    // Duplicate the parallel tube and move it up another segmentHeight
    // Position at segmentHeight * 2: Z should be segmentHeight * 2 + tubeWidth * 2
    // X offset: segmentLength (broad-side length of the segment)
    const parallelTubeDuplicateZ = segmentHeight * 2 + tubeWidth * 2;
    const parallelTubeDuplicateStart = localOrigin + vector(tubeX + segmentLength, tubeY + tubeWidth, parallelTubeDuplicateZ);
    const parallelTubeDuplicateEnd = localOrigin + vector(tubeX + segmentLength, tubeY + tubeWidth + shortenedLength, parallelTubeDuplicateZ);
    createTube(context, baseId + "parallelTubeDuplicate",
        parallelTubeDuplicateStart,
        parallelTubeDuplicateEnd,
        halfTube, halfInner, tubeWidth, tubeWallThickness);
    
    // Apply offset to parallel tube duplicate: -0.5 on Z
    const parallelTubeDuplicateQuery = qBodyType(qCreatedBy(baseId + "parallelTubeDuplicate" + "outer", EntityType.BODY), BodyType.SOLID);
    const parallelTubeDuplicateOffsetTransform = transform(vector(zero, zero, -0.5 * inch));
    opTransform(context, baseId + "parallelTubeDuplicateOffset", {
        "bodies" : parallelTubeDuplicateQuery,
        "transform" : parallelTubeDuplicateOffsetTransform
    });
    
    // Query all bodies created by this composite
    const allCompositeBodies = qBodyType(qCreatedBy(baseId, EntityType.BODY), BodyType.SOLID);
    
    // Calculate transform: rotate around Z axis by facingDirection, then translate by offset
    var finalTransform = transform(offset); // Default to translation only
    if (abs(facingDirection) < 1e-6 * degree)
    {
        // No rotation needed
        finalTransform = transform(offset);
    }
    else
    {
        // Create rotation around Z axis through origin
        const zAxisLine = line(localOrigin, vector(0, 0, 1)); // Z axis
        const rotationTransform = rotationAround(zAxisLine, facingDirection);
        const translationTransform = transform(offset);
        // Apply rotation first, then translation
        finalTransform = translationTransform * rotationTransform;
    }
    
    // Apply transform to all composite bodies
    opTransform(context, baseId + "compositeTransform", {
        "bodies" : allCompositeBodies,
        "transform" : finalTransform
    });
    
    // Return the indexed object references
    return createdObjects;
}
